{"pages":[],"posts":[{"title":"크롤링 그리고 파싱 #2","text":"크롤링 시리즈 크롤링은 왜 하는걸까 꼭 Python, Node.js 로만 가능할까? 크롤링을 하는데 알야야 할 것은? 꼭 Python, Node.js 로만 가능할까?정답부터 말하면 그렇지 않다. 크롤링 강좌, 자료 등에는 자주 등장하는 조합이 몇가지 있다. 가장 많이 등장하는 조합은 Python + BeautifulSoup Python + Selenium Node.js + cheerio Node.js + Selenium 이런 조합이 가장 많이 눈에 띄는데 가장 눈에 띄는 조합은 당연 Python + BeautifulSoup 이다. 가장 아름다운 하나의 답이 존재한다 라는 디자인 철학에서 알 수 있듯이 주변에서 사용해본 사람들은 모두 쉽고 빠른 속도로 개발할 수 있다고 한다. 심지어 웬만한 작업 (머신러닝, 웹서버, etc) 은 모두 할 수 있으니 관련 자료가 많지 않나 싶다. (심지어 Node.js 설치하다보면 파이썬이 같이 설치된다) 물론 나는 그런 내용과 관계 없이 크롤링 작업에 파이썬을 써본적은 없다. 주로 Java + Selenium + Jsoup Java + OkHttp + Jsoup Node.js + request + cheerio Node.js + puppeteer + cheerio 이런 조합으로 많이 작업했다. 물론 따로 특정 환경에서 필요하면 그 환경에 맞춰서 작업했다. C# 코드를 작성한적도 있고 JQuery를 사용한적도 있다. 즉, 크롤링을 하는데 있어서 사용하는 언어 등은 전혀 문제가 되지 않는다. 환경에 따라 난이도의 차이는 있을지 몰라도 ‘저는 파이썬을 할 줄 몰라서 못할것 같아요’ 같은 일은 없다는 것이다. 당연히 저는 프로그래밍을 못해서 크롤링을 못해요 라는 말도 하지 않아도 된다. 이미 다양한 자료가 있고 심지어 VBA 등에서도 크롤링이 가능하다. 구글 스프레드시트를 사용해서 하는 크롤링도 본 적 있으니 그저 찾아보기만 하면 된다. 대부분의 경우에 내가 해야 할 작업은 이미 누군가가 열심히 삽질해서 얻은 노하우를 인터넷에 공개해 놓았기 때문에 처음부터 끝까지 홀로 삽질할 걱정은 하지 않아도 된다.","link":"/2019/05/20/Crawling/crawling-parsing-02/"},{"title":"뜻하지 않은 유목민 인생 그리고 바뀐점","text":"유목민[nomad] : 한곳에 정착하지 않고 다른 장소로 이주하면서 생활하는 사람이나 그런 사람들로 구성된 사회 네 최근 몇 년간의 저를 나타내는 단어 중 하나입니다. 정확히는 대학에 입학한 시점부터 바뀐 삶의 패턴이라고 할 수 있겠네요 저는 흔히 말하는 지방러입니다. 그리고 학교는 아직 위치에 대해 의견이 분분하니 1호선으로 타협하겠습니다. 아마 경험이 있으신 분들은 이쯤에서 감이 오실 겁니다. 네 고등학교 졸업과 함께 타지에 던져진 야생동물이 되었습니다. 그리고 저는 몇몇 사유로 기숙사를 선호하는 편이라 4학년인 현재도 기숙사에 거주 중입니다. 종강하면 본가로 돌아가는 흔한 기숙사생이죠. 여기에 군대 같은 걸 끼얹으니 이제는 10년 가까이 썼던 본가의 침대도 숙박업소에 온 느낌이 들고 있습니다. 내 집은 어디인가 사람이 그럴 수 있냐고요? 네 그러더라고요. 최근 5년간 거주지를 생각해보니 다음과 같았습니다. 시기 거주지 14년 1분기 본가 14년 2분기 기숙사 14년 3분기 본가 14년 4분기 기숙사 15년 1분기 본가 15년 2분기 기숙사 15년 3분기 강원도 중간 중간 노숙 17년 2분기 강원도 17년 3분기 본가 17년 4분기 기숙사 18년 1분기 본가 18년 2분기 기숙사 18년 3분기 본가 18년 4분기 기숙사 19년 1분기 이곳 저곳 생각해보니 성인이 된 후 한 지역에 3개월 이상 있던 시기는 군 생활 기간뿐입니다. 더군다나 군대도 훈련이 많은 부대를 다녀왔더니 자꾸 들고 다니기 편한 제품에 눈이 가고 개인물품을 늘리기 껄끄러워졌습니다. (국방부 네가 날 이렇게 만들었다) 물건을 살 때도 이런 기준으로 구매를 합니다. 휴대하기 편한가 (캠핑용품인가) 자주 쓸 건가 다른 물건과 기능이 겹치지 않는가 몇 시간 들고 다녀도 무리 없는가 이렇게 몇 년 지내다 보니 지금에 와서는 다음과 같은 상태가 되었습니다. 개인 짐 택배 상자 1개 분량 (본가에도 그렇게 많지는 않습니다) 평상시 가방에는 노트북뿐 옷은 항상 부피가 작은 옷뿐 (겨울에도 반팔) 세면도구도 여행용품 위주 아마 살기 불편하지 않냐고 하시는 분들도 계실 텐데 글쎄요? 적응한 것인지 아니면 원래 그런지는 모르겠지만 딱히 불편하다는 느낌은 없고 거주지 이동이 많고 여러 지역을 돌아다니다 보니 오히려 이런 형태가 이동하기 편해서 딱히 불편하다고는 느끼지 못하고 있는데 가끔 몇몇 불편한 점이 있긴 한데 우편물은 어디로 받아야 하나 인터넷 쇼핑 시 배송지를 잘 확인하지 않으면 다른 곳으로 배송된다 항상 짐을 전부 풀지 못한다 이 정도가 되겠네요. 자주 있는 일은 아니라서 큰 불편은 느끼지 못하고 있지만 취업해서 자취를 시작하게 되면 그때는 또 어떻게 느낄지 모르겠네요.","link":"/2019/03/01/DailyLife/뜻하지-않은-유목민-인생-그리고-바뀐점/"},{"title":"크롤링 그리고 파싱 #1","text":"크롤링 시리즈 크롤링은 왜 하는걸까 꼭 Python, Node.js 로만 가능할까? 크롤링을 하는데 알야야 할 것은? 크롤링(crawling) 또는 스크래핑(scraping)그리고 파싱(parsing)은 구분하기가 애매하다고 생각한다. 물론 파싱은 컴파일러 설계 등에서 사용되는 의미있는 토큰으로 나누어 파스트리를 만드는 파싱의 의미도 있지만 여기서는 단순히 데이터를 가공하여 정보로 만드는 과정을 말하려고 한다. 인터넷의 발달에 따라 우리는 기존의 신문, 잡지등에서 웹브라우저로, 앱으로 정보 수집의 창구가 이동하고 있다. 그리고 어떠한 정보를 가지고 있는가, 얼마나 빠르게 습득하느냐도 점차 중요해지면서 주기적으로 데이터를 수집하는 업무가 증가하고 있으며 이로 인하여 인터넷에서 데이터를 가져오는 과정을 자동화하는 크롤링이 관심을 받고 있다. 특히 요즘에는 인터넷 강의 업체에서도 크롤링을 통한 업무 자동화 등 다양한 홍보를 하고 있다. 그런데 대부분 50 ~ 80 만원 정도의 가격대를 형성하고 있는데 사실 개인적인 기준에서는 수강하기에는 좀 부담스러운 가격이긴 하다. 더군다나 대부분은 파이썬 등 프로그래밍 언어를 사용하는 강의이고 어느정도 프로그래밍이 가능해야 또는 최소한 개념은 알아야 수강할 수 있는 강의라는 얘기를 들었다. 그래서 이번에는 정리 겸 크롤링에 대해 써보려고 한다. 크롤링은 왜 하는걸까크롤링을 하는데는 다양한 이유가 있다. 구글, 네이버 등 검색 엔진에서 자사 서비스에 검색 결과로 노출하기 위한 크롤링부터 기업이 CS 업무용 카페를 모니터링하기 위한 크롤링, 연구를 위한 데이터 수집용 크롤링, 그 외 업무에 필요한 데이터 수집용 크롤링 등 다양한 목적에서 사용되고 있다. 기업업무 등에서 사용되는 크롤링이던 개인적으로 쓰는 크롤링이던간에 사실 크롤링은 시간만 충분히 있다면 사람이 처리할 수 있는 작업이다. 컴퓨터를 켜고 해당 사이트에 접속해서 원하는 페이지를 열고 원하는 데이터 (제목, 내용 등)을 가져오고 엑셀이나 텍스트 파일 등 필요한 형태로 저장 단순하게 이 과정만 반복하면 된다. 이 업무가 필요 없을 때 까지 말이다. 만약 회사에서 맡은 업무중 하나가 100개의 뉴스 사이트를 확인하면서 전날 새로 올라온 기사를 수집하는 업무라고 가정한다면 아마 처음 몇일은 열심히 하겠지만 다음날부터는 보기만 해도 지겹고 진절머리날 것 이다. 물론 오늘의 뉴스 헤드라인 전달 등 몇개 안되는 작업이라면 그정도 쯤이야 하면서 하는 사람도 있을지도 모른다 하지만 군대에서 매 주 기록 정리해서 보고하는 일 조차 귀찮아 했던 사람이 나다. 저런 업무를 매일 또는 주기적으로 할 수 있을리가 없다. 더군다나 해야할 일은 자료 수집만 있는것도 아니니 일이 많은 날에는 초조하기도 하고 짜증도 날 것이다. 이러한 시점에서 필요한것이 바로 크롤링이다. 크롤링용 시스템을 운영할 수 있는 기업에서는 기존에 데이터 수집에 소모되던 인력을 다른곳에 투입할 수 있게 되며 업무상 데이터 수집이 주기적으로 필요한 개인은 데이터 수집 업무에 소요되던 시간을 다른 업무나 휴식에 쓸 수 있을것이다. 개인적으로는 크롤링 작업을 자동화 해서 나쁠것은 없다고 생각한다.","link":"/2019/05/16/Crawling/crawling-parsing-01/"},{"title":"크롤링 그리고 파싱 #3","text":"크롤링 시리즈 크롤링은 왜 하는걸까 꼭 Python, Node.js 로만 가능할까? 크롤링을 하는데 알야야 할 것은? 크롤링을 하는데 알아야 할 것은?크롤링을 하려면 다음과 같은 내용을 한번 생각해 봐야한다. 내가 원하는 정보가 정확히 무엇인가 어떤 언어(환경)을 쓸것인가 특히 1번은 크롤링 뿐만 아니라 흔히 말하는 IT 서비스가 필요한 사람들 중 상당수의 문제이기도 하다. 실제로 아르바이트 하던 쇼핑몰에서 다른 쇼핑몰의 스마트폰 애플리케이션을 보고 우리도 저런 애플리케이션을 만들어달라는 요청을 했었다. 받은 내용을 보니 단순히 모바일 쇼핑몰 웹페이지를 앱으로 감싼 구조 였으며 PUSH 메시지 등의 기능은 전혀 없고 말 그대로 바로가기 정도의 역할을 하는 구조였다. 혹시나 싶어서 내용을 설명하고 이를 하기 위해 필요한 최소 비용을 설명하니 ‘아 그런거면 우리는 그런거 안하죠 그거 할거면 그 돈을 왜 써요’ 라는 답변을 받았다. 저런 대화를 수십번을 하다보니 다른 아르바이트나 외주를 할 때도 항상 먼저 하는 작업이 정말로 원하는게 무엇인지 다시 물어보는 것 이었다. 의외로 많은 사람들이 이 작업을 왜 해야하는지 모르는 경우가 많았으며 대화를 하다보면 처음 요구사항이 A 였다면 대화가 끝난뒤에는 Z 정도 되는 경우도 자주 있었다. 2번의 어떤 환경을 쓸것인가는 업무에 적합한 내용을 선택하면 되는 문제니 개인의 취향과 업무 환경에 맞추면 된다. VBA 쓰는 사람이면 VBA를 사용하면 되고 Node.js를 쓰면 Node.js 파이썬이면 파이썬 용도와 취향에 맞게 고르면 된다. 그럼에도 이렇게 언급하는 이유는 차후에 나올 Server Side Rendering 과 Client Side Rendering 의 차이 때문이다. 크롤링을 하기 위한 기본 지식 SSR (Server Side Rendering)과 CSR (Client Side Rendering) 덤으로 SPA CSS Selector Query와 Parameter 그리고 body SSR (Server Side Rendering)과 CSR (Client Side Rendering) 덤으로 SPA결국에는 화면을 누가, 어떻게 렌더링하느냐는 책임전가의 문제이다. 자세한 내용은 알면 좋겠지만 핵심부터 말하자면 우리가 크롤링하려는 사이트가 데이터가 들어있는 상태로 응답을 하는가 응답먼저 하고 Javascript를 이용해서 데이터를 가져오는가 차이이다. 이 데이터의 로딩 시점의 차이 때문에 우리는 단순히 http request를 요청 할 것인가 headless browser를 사용 할 것인지 결정해야 한다. 만일 크롤링하려는 사이트가 데이터가 들어와 있는 상태의 html을 반환한다면 매우 편리하고 쉽겠지만 javascript를 사용해서 데이터를 로딩하는 사이트도 많기 때문에 headless browser또한 고려해야 한다. 웹 사이트를 분석해서 headless browser를 사용할지 결정할 수 도 있겠지만 단순히 Okhttp 등을 써서 요청을 날렸는데 받은 결과에서 데이터들이 안보인다 싶으면 사용하면 될 듯 하다. 참고로 headless browser는 웹 브라우저를 GUI없이 돌리는것을 의미한다. GUI만 빠지기 때문에 javascript를 사용할 수 있으며 스크린샷, 브라우저 테스트 등을 하는데 유용한다. Query와 ParameterAPI를 컨트롤하기(웹페이지를 조건에 맞춰 띄우기) 위해 3가지를 쓸 수 있다. parameter query body 3번 body의 경우에는 주로 form 등의 데이터를 담는데 사용된다. URL에서는 확인할 수 없고 크롤링 하려는 페이지가 form데이터나 json 등의 데이터 등을 전달해야 응답해주는 페이지라면 사용되겠지만 아직까지 그런 일은 거의 없었다. 1번 parameter는 URL에 포함되는 값 이다. 예를들어 https://duswnd25.github.io/2019/05/20/Crawling/crawling-parsing-02/ 라는 주소에서 https://duswnd25.github.io 라는 웹사이트 주소 이후에 /값 형식으로 붙는것이 parameter라고 보면된다. 지금 주소에서는 각각 2019, 05, 20, Crawling, crawling-parsing-02 총 5개가 parameter라고 보면된다. 2번 query는 주소 이후 ? 다음부터 시작되는 값 이다. ?key=value&amp;key=value 형태로 붙게된다. https://www.google.com/?q=검색 이 주소에서 parameter는 없으며 q=검색 부분이 query 이다. 그렇다면 어떤 경우에는 query를 쓰고 어떤 경우에는 parameter를 쓸까? 정답은 없다. 이를 어떻게 사용하는가는 그 사이트를 또는 api를 개발한 개발자의 판단 또는 취향이기 때문에 딱히 뭐라고 하기 어렵다. 나같은 경우에는 보통 레이아웃 별로 parameter를 써서 url을 매핑하고 query를 써서 조건을 다는 편이다. 예를들어 집 주소를 parameter와 query를 써서 만든다고 한다면 http://지도.com/서울시/용산구/전자상가?건물=선인상가&amp;호수=000 이런 식으로 자주 하는 편이다. 당연히 모든 parameter를 query로 바꿀수 도 있고 그 반대도 가능하다. 위의 주소도 http://지도.com/서울시/용산구/전자상가/선인상가/000 라던가 http://지도.com?도시=서울시&amp;구=용산구&amp;종류=전자상가&amp;건물=선인상가&amp;호수=100 처럼 바꿀 수 있다. 때문에 원하는 조건에 따라 크롤링을 하려면 둘 다 살펴봐야 한다.","link":"/2019/06/04/Crawling/crawling-parsing-03/"},{"title":"NodeJS + Express 의 잔여 메모리와 응답시간","text":"작년 초 지인의 소개로 모 인디게임의 서버 프로그램을 개발하였습니다. 서버의 주 역할은 주기적으로 (짧게는 몇 초부터 길게는 5분) 사용자의 게임 데이터를 서버로 전송해 운영팀이 게임 상황을 파악할 수 있게 해주거나 사용자 차단, 일일 보상 체크 등의 간단한 역할만 수행하고 있습니다. 처음에는 사용자의 수가 적었기 때문에 10 rps (초당 요청 수) 정 도로 아무런 문제가 없었지만 최근 몇 달간 사용자가 급증하기 시작하면서 평균적으로 40rps 를 유지하고 있으며 피크타임 또는 공격을 받을 때는 80 rps까지 올라가는 상황이 벌어지고 있습니다. 이와 동시에 응답시간이 초기에는 12s 미만으로 쾌적한 모습을 보여주었지만 요즘 들어 자주 915s까지 올라가는 모습을 보고 원인을 파악하고 해결해야 할 필요성이 느껴져서 일주일간의 데이터를 분석하기로 했습니다. 처음에는 피크시간대의 요청 증가로 인해 발생하는 현상이라고 생각했지만, 결과는 전혀 달랐습니다. 피크 시간대에는 1개의 서버 인스턴스가 하나 더 추가되는 것을 고려 하더라도 평소와 성능 차이는 크지 않았으며 오히려 피크 이외의 시간대에 성능 저하가 발생하는 경우가 더 많았습니다. 이상하게 생각되어 해당 시간대의 데이터를 집중적으로 분석하던 중 사용자 증가로 메모리 사용량 초과가 지속해서 발생하였고 PM2의 cluster 수를 2에서 1로 조정하게 되었는데 그 순간 서버의 성능이 개선되었고 성능 저하의 원인을 메모리 사용량을 중점으로 찾아보았습니다. 관찰 결과 PM2 클러스터의 수를 1로 지정했을 때 최초 실행 시 서버의 메모리 사용량은 약 250MB이며 특정 시점부터 메모리 사용량이 증가하면서 384MB까지 증가하였고 이 구간에서 메모리 사용량이 증가할수록 응답시간도 증가하는 것을 확인할 수 있었습니다. 따라서 성능 저하의 문제는 메모리와 관계가 있다는 결론을 내릴 수 있었고 다음과 같은 가능성을 고려하여 자료를 찾아보았습니다. 어디선가 메모리 누수가 진행 중이다. 서버의 메모리가 부족하다 (최대 512MB) 비효율적인 로직이 존재한다. 이 중 2번은 현재 1개의 서버 인스턴스 당 1개의 cluster만 돌아가고 있으며 메모리 사용량 모니터링 결과 384MB에 도달하면 cluster instance를 재시작하게 설정한 상황에서도 처리량에는 큰 문제가 없었기 때문에(재시작될 때 해당 인스턴스가 처리 중인 요청은 누락되긴 합니다.) 제외하였으며 3번은 로직이 복잡하지 않고 최근 다음과 같은 작업이 게임 쪽에서 진행 중이라 제외하였습니다. 사용하지 않는 API 제거 out of dated 된 모듈, DB 등의 마이그레이션 새 스펙에 맞게 서버 및 클라이언트 재개발 결국 중점적으로 찾아보게 된 건 1번 메모리 누수 문제였고 다음과 같은 내용을 알게 되었습니다. Node.js 는 64bit에서는 기본으로 1.4GB를 메모리 한계로 잡는다. 그래서 메모리가 1.4GB 이하인 환경에서는 메모리 제한이 필요하다. V8의 GC 역시 메인 스레드에서 진행되며 사양보다 과도한 요청을 처리하느라 GC가 끼어들 틈이 없다. 잘못된 요청으로 인한 오류가 제대로 처리되지 못하고 구천을 떠돌고 있다. 이 중 2번의 경우에는 순간적으로 80rps로 급상승할 때도 모니터링 결과 GC는 꾸준히 수행 중에 있었으며 메인 스레드의 event loop는 평소 10% 미만의 사용률을 보이고 있었습니다. 따라서 1번과 3번의 해결책을 시도해보았습니다. 1번의 해결책 1node --max-old-space-size=512 server.js PM2의 경우 다음과 같이 설정하면 된다고 합니다. 1234567{ \"apps\": [ { \"node_args\": \"--max_old_space_size=512\" } ]} 3번의 해결책 123app.use(function(err, req, res, next) { // handle error}); 하나씩 적용해보면서 결과를 관찰하였는데 3번의 해결책의 경우 의외로 큰 성능 개선을 보여주었습니다. 흔히 툴키드라고 불리는 악성 사용자들의 비정상적인 요청이 처리하지 않은 오류를 발생시켰고 제대로 처리되지 않아 한동안 서버 내부에서 고아 상태가 되었던 것 같습니다. 이러한 부분은 다음 버전부터는 express-async-errors 모듈 등을 통해 전역적으로 오류를 처리하는 방향으로 결정하였습니다. 1번의 해결책의 경우에는 큰 효과는 못 보고 있는데 PM2에서 재시작하는 부분도 있어서 좀 더 지켜봐야 할 것 같습니다. 다만 메모리 사용량이 이전보다는 완만하게 증가하는 경향을 보이는데 해당 옵션 때문인지는 판단이 잘 안 되고 있습니다. 최종적으로 서버의 응답시간은 다음과 같이 변했습니다. 과거 Ratio Response Time MAX 30s 99% 13s 95% 7s 50% 0.7s 현재 Ratio Response Time MAX 17s 99% 5s 95% 2s 50% 0.2s RPS는 약 10 정도 더 늘어났으며 피크시간대에도 더 나은 성능을 보여주기 시작했습니다. 다만 이 수치는 해당 기간 사용자 수가 20% 이상 증가하여 서버 인스턴스를 평균적으로 1개 정도 추가하였음을 고려하고 보시면 감사하겠습니다. 다음에 좀 더 성능 개선을 하면 어느 정도까지 성능개선이 될지 궁금하네요. 참고 Node.JS ( &amp; pm2 ) Process Memory Limit Production best practices: performance and reliability Node.js 최적화, 메모리관리를 위한 flag nodejs 메모리 누수 Static Memory Javascript with Object Pools Memory Leaks in NodeJS | Quick Overview","link":"/2019/02/27/NodeJs/NodeJS-Express-의-잔여-메모리와-응답시간/"},{"title":"Smart Mirror #1","text":"스마트 거울?제가 스마트 거울을 처음 접하게 된 계기는 여기였습니다. Max Braun Medium 그리고 검색해보면 아래와 같이 많은 사진들이 나옵니다. 많은 프로그래머들이 짬내서 한 번씩 만들어보고 있고 저마다 자신만의 거울을 만들고 있습니다. 당연히 거울을 만드는 방법도 전부 다릅니다. 라즈베리파이, 태블릿PC 등등 재료도 다르고 모니터를 쓰느냐 거울을 잘라서 만드느냐도 갈립니다. 물론 저는 모니터를 살 돈도, 필름을 살 생각도 없었습니다. 저는 거울을 잘 안보거든요. 그런데 작년에 봤던 Android Vision을 이번에 다시 보게 되었고 스마트 거울에 적용하면 어떨까 싶었습니다. 그 당시 제가 봤던 Android Vision은 카메라에 나온 얼굴을 찾고 행복도를 표시해 주는 기능이었습니다. 그럼 이를 활용해서 기분에 따라 인사말이 달라지는 거울을 만들면 어떨까 싶었고 직접 만들어보기로 했습니다. 준비물Android OS가 설치되어 있는 기기 (전 휴대폰과, 태블릿으로 했습니다)Android Studio기존의 거울은 크게 두가지로 나뉘었습니다. 라즈베리파이를 디스플레이 뒷면에 붙이거나, 거울 한쪽을 잘라 태블릿을 붙여놓거나요. 하지만 저는 디스플레이 살 돈은 없고 거울 한쪽을 잘라 태블릿을 붙이기엔 너무 아깝다고 생각했습니다. 그래서 기존의 대형 거울이 아니라 손거울, 탁상거울 컨셉으로 나가기로 했습니다. 그래서 안드로이드 앱을 만들기로 결정했습니다. 참고Android VisionMax Braun Medium","link":"/2017/11/25/Android/SmartMirror/Smart-Mirror-1/"},{"title":"Smart Mirror #2","text":"Android Vision 알아보기먼저 목표인 기분에 따라 달라지는 인사말 을 책임져줄 Android Vision을 알아보기로 했습니다. 여기에서 Google Sample을 찾아볼 수 있는데요 저는 여기서 FaceTracker를 사용하려고 합니다. FaceTracker 실행하기실행은 그저 소스를 받아와서 컴파일 하면 끝입니다. 실행시키면 다음과 같은 화면을 볼 수 있습니다. 다만 이 화면은 FaceTracker는 기본적으로 후면 카메라를 사용하게 되어 있는데 거울을 만들기 위해 전면으로 바꿔놓은 상태라 캡쳐하기 좀 힘들어서 비틀다보니 몇몇 얼굴이 인식되지 않았는데요. 실제로는 인식률이 좋고 거울을 여러명이 같이 볼 일은 별로 없으니 상관 없을듯 합니다. Android Vision 소스 수정Class 분리이제 제 필요와 실력에 맞게 너프할 차례입니다. 먼저, 제가 알아보기 쉽게 하나로 합쳐져 있던 클래스를 분리하고 변수명도 제 취향에 맞게 정리하였습니다. 카메라 전환저는 거울이 목표이기 때문에 후면카메라를 전면으로 전환하려고 합니다. 메인 액티비티에서 이 부분을 이렇게 변경해 주면 됩니다. 거울이 목표이니 별도의 전환 기능은 필요 없습니다. 프리뷰 사이즈 조정은 마지막에 다루려고 합니다.","link":"/2017/11/25/Android/SmartMirror/Smart-Mirror-2/"},{"title":"Smart Mirror #3","text":"이제 카메라 위에 정보를 띄워봅시다.먼저 저는 다음과 같은 정보를 띄우려고 합니다. 날씨 인사 다른 정보는 차차 추가하기로 하고 일단 저 두가지만 해보기로 합니다. Layout 인사말 layout 123456789101112131415161718&lt;me.grantland.widget.AutofitTextView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/greeting_text\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_gravity=\"center\" android:gravity=\"center\" android:maxLines=\"1\" android:padding=\"@dimen/default_pad\" android:textAlignment=\"center\" android:textColor=\"@android:color/white\" android:textStyle=\"bold\" app:sizeToFit=\"true\" tools:showIn=\"@layout/activity_main\" tools:text=\"안녕하세요.\" tools:textSize=\"50sp\" /&gt; 날씨 layout 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"200dp\" android:layout_height=\"100dp\" android:gravity=\"center|start\" android:orientation=\"horizontal\" android:padding=\"@dimen/default_pad\" tools:showIn=\"@layout/activity_main\"&gt; &lt;ImageView android:id=\"@+id/main_weather_image\" android:layout_width=\"80dp\" android:layout_height=\"80dp\" tools:src=\"@drawable/ic_cloud\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;me.grantland.widget.AutofitTextView android:id=\"@+id/weather_temp_text\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:gravity=\"center\" android:maxLines=\"1\" android:padding=\"4dp\" android:textAlignment=\"center\" android:textColor=\"@android:color/white\" app:sizeToFit=\"true\" tools:text=\"60°C\" /&gt; &lt;me.grantland.widget.AutofitTextView android:id=\"@+id/weather_type_text\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:gravity=\"center\" android:maxLines=\"1\" android:padding=\"4dp\" android:textAlignment=\"center\" android:textColor=\"@android:color/white\" app:sizeToFit=\"true\" tools:text=\"SUNNY\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 그리고 카메라 preivew가 있는 레이아웃에 다음과 같이 추가하였습니다. 12&lt;include layout=\"@layout/item_weather\" /&gt;&lt;include layout=\"@layout/item_hello\" /&gt; JAVA이제 레이아웃을 추가하였습니다. 하지만 소스를 잘 보면 tools로 텍스트와 이미지를 설정하였습니다. 이는 개발의 편의를 위해 개발 화면에서만 값이 보여지고 실제 화면에서는 보여지지 않습니다. 목표는 날씨, 기분에 따라 변하는 메시지, 이미지 이기 때문에 Java에서 이를 변경하도록 하겠습니다. 메시지로 사용할 resource다국어 지원을 위해 별도의 xml 파일을 만들어서 관리하도록 하였습니다. 저는 파일명은 각각 greeting_message_array, weather_array로 하였습니다. 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"greeting_messages\"&gt; &lt;item&gt;안녕하세요.&lt;/item&gt; &lt;item&gt;반갑습니다.&lt;/item&gt; &lt;item&gt;환영합니다.&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt;&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"weather_type\"&gt; &lt;item&gt;맑음&lt;/item&gt; &lt;item&gt;눈&lt;/item&gt; &lt;item&gt;비&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 인사말을 만들 클래스 별도의 클래스에서 인사말을 만들게 하였습니다. 굳이 이렇게 할 필요는 없지만 추후 이름을 붙인다거나 등의 작업을 위해 분리하였습니다. 1234567891011121314151617package app.kimyeonjung.visionmirror.greeting;import android.content.Context;import java.util.Random;import app.kimyeonjung.visionmirror.R;public class GreetingBuilder { private Context context; public GreetingBuilder(Context context) { this.context = context; } public String getRandomGreetingMessage() { String[] messageArray = context.getResources().getStringArray(R.array.greeting_messages); return messageArray[new Random().nextInt(messageArray.length - 1)]; }} 날씨정보 아직 정보를 인터넷에서 받아오는 부분은 구현하지 않았기 때문에 아무 값이나 넣어보았습니다. 123456789101112131415161718192021222324252627282930313233package app.kimyeonjung.visionmirror.weather;import android.content.Context;import java.util.Random;import app.kimyeonjung.visionmirror.R;public class WeatherBuilder { private Context context; public WeatherBuilder(Context context) { this.context = context; } public int getWeatherImage() { int[] images = { R.drawable.ic_cloud, R.drawable.ic_electric, R.drawable.ic_partly_cloudy, R.drawable.ic_rain, R.drawable.ic_snow }; return images[new Random().nextInt(images.length - 1)]; } public int getTemperature() { int[] temps = {60, 50, 13, 20, 16, 165, 10, 6514, 651, 65}; return temps[new Random().nextInt(temps.length - 1)]; } public String getType() { String[] types = context.getResources().getStringArray(R.array.weather_type); return types[new Random().nextInt(types.length - 1)]; }} 그리고 마지막으로 액티비티에서 값을 설정해주면 123456789AutofitTextView greetingTextView = findViewById(R.id.greeting_text);greetingTextView.setText(new GreetingBuilder(this).getRandomGreetingMessage());WeatherBuilder weatherBuilder = new WeatherBuilder(this);ImageView weatherImageView = findViewById(R.id.weather_image);weatherImageView.setImageResource(weatherBuilder.getWeatherImage());AutofitTextView temperatureView = findViewById(R.id.weather_temp_text);temperatureView.setText(String.valueOf(weatherBuilder.getTemperature()));AutofitTextView typeView = findViewById(R.id.weather_type_text);typeView.setText(weatherBuilder.getType()); 결과짠~! 이렇게 카메라 위에 정보가 출력되었습니다!","link":"/2017/11/25/Android/SmartMirror/Smart-Mirror-3/"},{"title":"Cluster 환경에서의 Parse Dashboard","text":"Node.js와 웹 프레임워크를 사용해 구현한 웹 서버는 생산성이나 편의성 면에서 확실히 매력이 있습니다. NPM의 방대한 라이브러리와 Javascript의 다양한 자료들은 부족한 실력에도 원하는 목적을 달성하게 도와줍니다. 저는 그중에서도 Node.js + Express + Parse Server + MongoDB + Parse Dashboard 구조를 주로 사용하는데 개인적으로는 Java를 좋아하지만, 학교 수업에서 배운 Tomcat + Servlet은 개인적으로는 취향에 맞지 않았고 SQL은 다들 사용하니 제 주변에선 잘 안 쓰는 MongoDB를 써보고 싶은 마음도 있긴 했지만 과거 Facebook에서 Parse.com이라는 서비스를 운영했을 때 사용한 경험이 좋아서 선호하는 경향도 있습니다. Parse가 오픈소스가 아닌 Facebook에서 호스팅 서비스를 할 당시에는 서버 인프라를 제가 고려할 필요가 없었지만 서비스 종료 후 오픈소스로 공개된 이후에는 사용자에게는 두 가지 선택지가 생겼습니다. Cloud 업체가 Parse를 호스팅하여 제공하는 서비스를 사용. 직접 Parse 서버를 호스팅하여 사용. 처음 이 소식을 접했을 때는 국내 업체는 Parse 호스팅을 제공하는 업체를 찾지 못하였고 외국 업체 일부가 있었으며 업체별로 어느 정도 커스텀이 들어갔기 때문에 제가 기억하는 Parse의 모습은 찾을 수 없었습니다. 또한, 당시에는 지금보다 더 지식이 없었기 때문에 외국 포럼을 검색하다 발견해서 커스텀하여 사용하고 있던 Cloud Job을 해당 호스팅 업체에 맞춰 마이그레이션 할 자신이 없었기 때문에 이왕 배우는 거 처음부터 손대보자는 생각으로 직접 Parse 호스팅에 도전하였습니다. 열심히 공부하면서 로컬에서 단순히 Node 서버만 띄웠을 때 (PM2나 cluster 사용 X)는 Dashboard에 접속하는 데 문제가 없었지만. Cloud 서버에 올리고 더 나은 성능과 가용성을 위해 Cluster를 적용하게 되었고 기쁜 마음으로 Dashboard에 접속한 저에게는 하얀 화면의 검은 글씨가 기다릴 뿐이었습니다. 이 문제를 해결하기 위해 stack overflow도 검색하고 다양한 문서를 찾아봤지만, 해당 문제는 공식 문서에도 없었으며 (지금은 모르겠습니다) 다른 개발자들이 올린 질문의 답변도 어느 하나 저에게 도움이 되는 답변이 없었으며 엉뚱한 답변이 많았습니다. 그러던 중 해당 문제의 솔루션에 대해 언급한 내용을 github의 issues 중 하나의 댓글에서 발견하였고 (왜 이게 공식 문서에 포함이 되지 않는지 아직도 의문스러운데 어느 정도 규모있는 기업에서는 Parse Dashboard를 사용하지 않고 다른 솔루션을 사용하지 않을까 싶습니다) 해당 내용은 다음과 같습니다. I ran into this issue after upgrading to 1.1.2 and I hunted down the root cause. As per PR #774 (this line of code), the cookie secret will be set to a random value if you do not set it yourself. This is intentional and documented in the CLI. So, if you are running in a load balanced environment (or in using NodeJS cluster) be sure to set your cookieSessionSecret: From CLI: 1--cookieSessionSecret \"your-secret-here\" From NodeJS (options is the 2nd argument of constructor): 12345new ParseDashboard({// settings here}, { cookieSessionSecret: 'your-secret-here'}); 즉, 별도의 cookieSession값을 지정하지 않으면 랜덤으로 값이 지정되는데 cluster 환경 또는 로드밸런싱 환경에서는 프로세스마다 해당 값이 다르게 지정되기 때문에 발생하는 문제 같습니다. 이 문제에 대해 해결책을 알려준 JeremyPlease 에게 감사합니다.","link":"/2019/02/09/NodeJs/Parse/Cluster-환경에서의-Parse-Dashboard/"},{"title":"Smart Mirror #5","text":"사용Library Jsoup OkHttp AutofitTextView otto API DarkSky ip-api 그외 Google New Rss 전체 과정계기처음 시작은 몇년 전 뉴스에 나온 Smart Mirror 에 관한 글My Bathroom Mirror Is Smarter Than Yours입니다. 당시 ‘오…… 저런것도 있구나….’ 생각하였고 따라서 해보고 싶었지만 당시 저는 군복무 중 이었고 그렇게 기억 한편으로 사라지게 되었습니다. 그리고 전역 후 학교를 다니던 중 우연히 다시 그 내용을 보게 되었고 이번에는 한번 해보자고 생각하여 틈틈히 만들어보게 되었습니다. 과정들어가며사실 smart mirror는 전세계에서 많은 개발자들이 Raspberry Pi를 활용하여 만들고 있습니다. Youtube 등에서 다양한 형태의 거울이 나오고 있는데 대부분은 대형 모니터에 반사 필름을 붙여서 만드는 형태 입니다. 즉, 프로그램 자체는 거울과 전혀 관계가 없으며 빈 화면에 정보만 표시하는 형태 입니다. 하지만 저는 모니터와 반사필름을 살 여유가 없었기 때문에 스탠드형 거울이 아닌 탁상거울 컨셉으로 스마트폰, 태블릿에서 작동하는 형태로 만들기로 하였습니다. 그래서 제 smart mirror는 반사필름이 아닌 기기의 카메라가 거울 역할을 하게 되었습니다. 이렇게 컨셉을 정하니 이전에 봤던 google의 android vision이 생각나서 예제 중 하나인 Face Tracker의 happiness 측정을 합칠 수 있지 않을까 싶었고 (이때 그만뒀어야 했는데….) happiness에 따라 인사말이 달라지게하는게 최종 목표중 하나가 되었습니다. 목표 정하기위의 과정을 거치며 다음과 같은 목표를 설정했습니다. 날씨 표시 현재 시간 기분에 따른 인사말 변경 뉴스 표시 다국어 지원 TTS 지원 구현날씨 구현날씨를 구현할때 다음과 같은 준비가 필요했습다. 현재 위치의 좌표 구하기 좌표의 날씨 구하기 Android의 Location Service를 사용하려면 위치관련 권한을 추가해야 하는데 가능하면 권한 확인 부분은 피하고 싶었습니다. 그래서 ip-api를 통해서 좌표 정보를 받아왔고 이를 darksky의 api를 활용해서 날씨 정보를 받아왔습니다. 정리하자면 순서가 다음과 같습니다. ip-api를 통해 ip주소의 좌표 받아오기 darksky의 api를 통해 1번에서 받아온 좌표의 날씨 받아오기 화면에 표시 여기서 기상청의 api를 사용하지 않은 이유는 다국어 지원을 고려하고 있었기 때문입니다. 국내, 국외를 별도로 구현하는 것 은 바람직하지 않다고 생각하여 전세계 날씨 정보를 제공하는 darksky의 api를 사용하였습니다. 마침 날씨 표시에 사용한 ip-api와 darksky모두 json형태로 값을 반환해주고 있었으며 이전에 json을 다뤄봤기 때문에 JsonObject를 이용하여 수월하게 작업할 수 있었습니다. 하지만 이 과정에서 데이터를 못 받아오는 현상이 있었는데 이는 위치조회와 날씨조회를 분리하여 구현하여 발생한 문제였으며 하나의 asynctask로 구현하였더니 사라졌습니다. 아마 위치정보 조회에서 문제가 있었지 않나 생각하고 있습니다. 하지만, 이렇게 끝난줄 알았으나 이 다음엔 네트워크 상태가 안좋을경우 표시까지 상당시간 지연되는 현상이 있었으며 이 때문에 카메라의 프리뷰가 보여질 때 까지 지연이 심해졌습니다. 그래서 asynctask로 변경하였고 카메라 프리뷰까지의 지연시간을 단축시킬 수 있었습니다. 역시 네트워크 작업은 비동기로 하는게 좋지 않나 싶은데 다른 상황에서는 어떨지 모르겠습니다. 인사말 표시인사말 표시의 핵심은 기분에 따른 메시지 변경인데 베이스로 사용한 예제에서는 메인 액티비티에서 해당 값을 받아오기 어려운 구조 였습니다.(제 실력에서는) 그래서 otto를 사용하였는데 얼굴 인식시 호출되는 메소드에서 publish하면 메인 액티비티에서 subscribe하는 구조로 해결하였고 얼굴인식이 실시간인 만큼 30초에 한번만 체크하게 하여 반복적인 인사말 출력을 제한하였습니다. ####뉴스 표시 뉴스의 경우 가장 간단한 부분이었는데 언론사의 선정이 가장 큰 문제였습니다. 언론사마다 성향이 있고 특정언론사를 싫어하는 분 들도 계셔서 결국 구글 뉴스의 RSS피드를 활용하였습니다. 날씨와 마찬가지로 요청 후 Jsoup파싱으로 처리하였습니다. 시간 표시그냥 안드로이드에서 지원하는 위젯 추가로 해결했습니다. 이게 제일 간단하더라고요 텍스트 사이즈 조정다양한 기기에서 구동을 목표로 했기 때문에 텍스트 사이즈는 어느정도 중요한 문제였습니다. 특히 뉴스의 경우 헤드라인이 길 수 록 2줄, 3줄로 개행되는 문제가 심했는데 이는 AutofitTextView 라이브러리로 해결했습니다. 개인적으로 자주 사용하는 라이브러리고 추후 직접 만들어보려고 합니다. TTSTTS (Text To Speech)의 경우 여러 라이브러리가 있습니다. 외국 라이브러리도 있고 국내 라이브러리도 존재합니다. 이들 라이브러리는 기기에 내장된 TTS보다 나은 성능을 보여 줄 때도 있지만 한가지 걸리는 점 은 네트워크를 사용한다는 것 입니다. 물론 사용 환경을 네트워크가 되는 환경으로 했지만 추후 유지보수, 별도의 설치, 용량 문제, 호환성 등을 생각해서 기기 기본 TTS로 결정하였습니다. 시연처음 실행시 화면 후기스마트거울은 참 매력적인 토이 프로젝트입니다. 이것저것 사용해보고 직접 만들경우 자신에게 커스텀 할 수 있는점이 매력적이죠. 나중에 여유가 생기면 스탠드 거울로 만들어서 아침마다 개인화된 브리핑을 받는게 목표입니다. 오픈소스로 공개된 스마트 거울도 많으니 관심있으신분은 직접 돌려보시는것 도 괜찮을듯 합니다.","link":"/2017/12/01/Android/SmartMirror/Smart-Mirror-5/"},{"title":"Smart Mirror #4","text":"실제 데이터 연동하기이제 틀은 갖췄으니 실제 데이터를 연동해야합니다. 이번에 구현할 부분은 지정시간 이후 Greeting 메시지 제거, 시간 표시 날씨정보 표시 입니다. 시간정보 표시먼저 일정시간 초과 후 메시지를 사라지게 만들겠습니다. 이 경우 핸들러를 사용하는게 가장 빠른데 다음과 같이 사용할 수 있습니다. 12345678910@SuppressLint(\"HandlerLeak\")Handler handler = new Handler() { public void handleMessage(Message msg) { super.handleMessage(msg); greetingTextView.setVisibility(View.GONE); timeContainer.setVisibility(View.VISIBLE); }};handler.sendEmptyMessageDelayed(0, 4000); 시간정보 표시는 그렇게 어렵지 않습니다. 이미 안드로이드에서 TextClock, DigitalClock , AnalogClock 등 위젯을 지원하고 있으며 별도의 작업 없이 추가만 하면 알아서 시간을 표시합니다. 123456789&lt;TextClock android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:textColor=\"@android:color/white\" android:maxLines=\"1\" android:alpha=\"0.5\" android:format24Hour=\"hh:mm:ss\" android:textSize=\"@dimen/greeting_message_size\" /&gt; 저는 이 중에서 TextClock을 사용하였는데 여기서 별도로 수정한 부분은 alpha와 format24Hour 입니다. 거울위에 반투명하게 표시하기 위해서 alpha값을 변경하였으며 TextClock은 기본적으로 시간과 분만 표시하기 때문에 초까지 표시하기 위해서 format24Hour 의 값을 hh:mm:ss로 설정하였습니다. 이 부분은 대부분의 언어, 프로그램에서 시간을 표시하는 방법과 동일합니다. 이제 반투명하게 시간을 표시할 수 있게 되었습니다. 날씨 정보날씨 정보는 현재 위치의 날씨를 인터넷에서 받아오게 구현하였는데 이 과정에서 기기의 GPS 등은 사용하지 않았습니다. 그 이유는 LocationManager 등을 사용하려면 위치정보 권한 요청을 해야 하기 때문에 번거롭다고 생각하였고 웹사이트에서 사용하는 ip 기반 위치 조회를 사용하였습니다. 그리고 날씨 정보는 기상청의 경우 국내만 제공하기 때문에 다국어 지원을 고려하는 입장에서는 그리 좋은 선택은 아니라고 생각하였고 참고 자료에서 사용중인 darksky의 무료 api를 사용하기로 하였습니다. 작업 순서는 ip주소를 활용한 위치 조회 darksky에서 현위치의 날씨 조회 두 순서 모두 데이터를 json형식으로 반환하기 때문에 okhttp로 값을 받아오고 이를 JSONObject로 가져왔습니다. 123456789101112131415161718192021222324252627282930313233343536WeatherItem weatherItem = new WeatherItem();OkHttpClient client = new OkHttpClient();Location location = new Location(\"\");location.setLatitude(37.4536);location.setLongitude(126.7317);Request request = new Request.Builder().url(\"http://ip-api.com/json\").build();try (Response response = client.newCall(request).execute()) { JSONObject responseJson = new JSONObject(response.body().string()); double latitude = responseJson.getDouble(\"lat\"); double longitude = responseJson.getDouble(\"lon\"); location.setLatitude(latitude); location.setLongitude(longitude);} catch (Exception e) { e.printStackTrace();}String url = \"https://api.darksky.net/forecast/\" + params[0].getResources().getString(R.string.darksky_key) + \"/\" + location.getLatitude() + \",\" + location.getLongitude();request = new Request.Builder().url(url).build();try (Response response = client.newCall(request).execute()) { JSONObject data = new JSONObject(response.body().string()); data = data.getJSONObject(\"currently\"); weatherItem.setSummary(data.getString(\"summary\")); weatherItem.setTemperature(data.getDouble(\"temperature\")); weatherItem.setImageId(iconResources.get(data.getString(\"icon\")));} catch (Exception e) { e.printStackTrace();}return weatherItem;","link":"/2017/11/26/Android/SmartMirror/Smart-Mirror-4/"},{"title":"파파를 타봤다. 이제 택시를 타기 힘들어졌다. 아니 못타겠다는게 맞을지도 모르겠다.","text":"사실 처음에만 해도 파파가 아니라 타다를 타려고 했다. 정확히는 파파를 이용하기 전까지는 파파의 존재 자체를 알지 못했다. 그도 그럴게 처음 봤을때는 출발지는 강남 도착지는 서울 전지역 이었는데 지금 확인해보니 출발 도착 모두 서울 전지역으로 확장했다. 즉, 강남에 올 일이 별로 없던 나는 파파를 접할 기회가 없었다. 특히, 파파는 네이밍의 문제인지 인지도의 문제인지 모르겠지만 검색하면 나오는게 없다. 진짜 없다. 이 글을 쓰면서 홈페이지 찾는데 한참 걸렸다. 영수증 메일은 cubecar.io로 오고 도메인이 papa.city다 그리고 나는 papa.co.kr, papa.com 등을 입력하고 있었다… 그래도 앱은 검색하면 잘 나오니 다행이다. 앞서 말했듯이 처음엔 택시를 타려고 했지만 지방에서 올라와 살면서 서울 - 경기 택시를 이용한 경험 중 좋은 경험이 없었다. 본가에서는 딱히 멀리 이동할 일도 없고 보통은 직접 운전하니 택시를 탄 경험이 적을지도 모르겠다. 하지만 이를 고려하더라도 나에게 있어 수도권 택시는 항상 최악의 경험만 가져다 주었다. 택시를 타면서 느낀 불편함을 정리해보자면 나는 분명 좀 더 이면도로로 들어간 장소를 말했는데 대로에 내려주기 지리를 잘 모른다고 빙빙 돌아가기 길 막히는데 열심히 운전했으니 팁 주라고 당당히 요구하기 대놓고 승차거부 하기 갑자기 시작하는 정치얘기 군인들에게 바가지 씌우기 차선변경하면서 켜지 않는 방향 지시등 분노의 질주를 4D로 보여주는 난폭운전 카풀, 승차공유 등 자신의 밥그릇 위협하는 서비스 하소연 이 밖에도 여러가지 있겠지만 지금 생각나는건 이정도인데 문제는 택시마다 한두가지 해당하는게 아니라 나는 언제나 한두가지 제외하고 전부였다. 그러다보니 요즘엔 택시를 타야할 때가 되면 고민되기 시작한다. 하지만 딱히 대체재가 없으니 결국엔 택시를 부르게 된다. 혼자 들고가기도 벅찰 정도로 짐이 많은데 어떻게 대중교통을 타거나 자전거를 탈까…. 눈앞이 깜깜해진다. 물론 택시를 잡을땐 지리를 모르는 나는 택시 기사들이 그렇게 싫어하는 카카오 택시만 사용한다. 택시기사들이 사용 거부한다 말이 많지만 내가 직접 나가서 택시 잡는것보다 훨씬 빠르더라 평균적으로 30초 정도면 바로 잡힌다. 그래도 앞서 말한 불편한점들은 어쩔 수 없다. 카카오 택시를 쓰면서 얻은건 요금 바가지 피하기 뿐이니까. 그러던 중 이번에도 택시를 타야하나 고민하다 눈앞에 타다 차량이 지나갔고 전에 한번 배차가 안된 경험이 있어서 고민하던 와중에 눈앞에 파파 차량이 지나갔다. 그 자리에서 바로 설치하고 가입한 뒤 호출했고 약 10분 뒤 차량에 탈 수 있었다. 차량이 택시에 비하면 턱없이 부족하기 때문에 배차에 시간이 걸리는게 단점이라면 단점이다. 그래서인지 앱 실행시 스플래시 화면에 ‘10분전에 미리 불러주세요 여유있게 타실 수 있습니다. 파파가 먼저 가서 기다릴게요.’ 라는 문구가 눈에 띈다. 급한 일 아니라면 먼저 호출하고 천천히 나가면 되는 문제라 큰 단점같지는 않다. 다음은 호출 뒤 하차까지의 내용이다. 완벽하게 똑같지는 않고 기억나는대로 썼기 때문에 조금은 다를 수 있다. (탑승전) 기사(전화) : 안녕하세요 파파 기사입니다. 지금 근처에 도착했는데 차가 밀려서 2분정도 늦을 것 같습니다. OO(호출시 내 위치로 지정한 곳)에 계신것 맞으신가요? 나(전화) : 네 바로 앞에 있어요. 기사(전화) : 네 알겠습니다. 잠시 후 뵙겠습니다. (탑승후) (문 자동으로 열린 뒤 탑승) 기사 : 안녕하세요. OO(목적지) 가시는것 맞으신가요? 나 : 네 맞아요. 기사 : 실내 온도랑 노래는 괜찮으신가요? 나 : 네 좋아요. 기사 : 혹시 별도로 원하시는 경로가 있으신가요? 나 : 아뇨 상관 없어요. 기사 : 그럼 네비게이션 경로대로 가겠습니다. 나 : 네. (차량 출발) (목적지 도착) 기사 : 도착했습니다. 좋은 하루 되세요. 나 : 감사합니다. 대략 이런 과정이었다. 차에 탑승한 뒤 웰컴 푸드로 준비 되어있는 견과류와 생수 중 생수를 마셨고 뒷자석에 마련되어 있는 태블릿으로 노래를 고르다 귀찮아져서 이전 이용객이 선곡한 노래를 계속 들었다. 와이파이는 생각보다 빨랐다. 태블릿 아래에는 휴대폰 충전이 가능한 케이블이 있었고 뒷자석 가운데에는 부드러운 담요, 그 옆좌석 앞에는 고데기가 있었다. 아침에 출근하는 사람들이 이동중에 자주 쓸 것 같았다. 목적지가 보여서 내릴 준비를 했는데 택시처럼 대로변에 내려주는게 아니라 정말 목적지 건물 입구 앞까지 들어가서 내려주셨다. 건물에서 차량 출입 관리하시는분도 자주 있는 일인지 바로 승객 있으세요? 라고 물어보셨고 기사님도 바로 네 라고 하시는걸 보니 이 기사님뿐만 아니라 이 서비스 자체가 정말 목적지 앞 까지 운전해 준다는 느낌을 받았다. 볼일을 끝내고 돌아가는길에도 파파를 이용했는데 둘 다 신규가입 쿠폰을 써서 버스와 비슷한 요금이 나왔고 시간은 8배 이상 단축되었다. 조금 다르긴 하지만 돌아갈때도 비슷한 경험이었다. 이렇게 2번의 경험 후 자연스레 택시를 못타겠다는 생각이 들었다. 승객이 말하기 전까지는 먼저 대화 불가 (정치 등 얘기 안해서 편했다) 모든 기사에 대한 친절교육 11인승에서 오는 편안하고 넉넉한 승차감 대륙의 미세먼지를 피할 수 있는 공기청정기 디테일한 친절 (경로, 온도 등) 골목길등을 통한 빠른 이동 과속, 칼치기, 신호위반 등 없는 안전운전 차선변경, 좌우회전시 항상 켜는 방향 지시등 하차시에도 골목 깊숙히 들어와서 정말 목적지 건물 앞에 내려주는 친절함 승하차시 자연스러운 인사 목적지가 길가로 되어 있으면 용무가 있는 건물을 물어보고 그 앞에서 내려주는 섬세함 이 이외에도 장점이 여러가지 있겠지만 바로 생각나는건 이정도 인 것 같다. 사실 어떻게 보면 당연하다 싶기도 한데 그 당연한것들이 택시에선 안되는게 문제가 아닐까 싶다. 뉴스를 보면 승차공유 서비스 기사들이 쉴틈 없이 다음 배차를 받는다고 하는데 써보니 바로 납득이 갔다. 불친절한 택시에 지친 사람들이 파파나 타다를 한번 타보면 다시는 택시를 타기 싫어질것이다. 택시를 자주 안타는 나도 더이상 택시를 못탈것 같다는 생각이 드는데 자주 타는 사람들은 어떤 심정일까 특히, 새벽에 자주 이동하는 사람이라면 안전측면에서 더 그럴 것 같다는 생각이 들었다. 나중에 다른분과 같이 이용하면서 기사님께 질문했을때도 저녁 늦은 시간대에 여성분들이 골목길이여도 집앞까지 가니까 자주 이용한다는 답변을 들었다. 이외에도 여러가지 질문했는데 교육을 진행하는 효과인지 기사님이 파파 서비스에 대해 정확히 알고 계신다는 인상을 받았다. 고용체계부터 주 이용 고객층, 요금 등 신뢰를 주는 답변을 하셨고 아직 확정되지 않은 내용에 대해서는 명확하게 그 부분은 아직 교육 받은게 없어서 모르겠다고 하셔서 신뢰가 갔다. 나중에 택시 기사들이 한번 이용 해봤으면 한다. 대다수가 이용해보지도 않고 무작정 반대만 한다는 느낌을 받았는데 정말 한번 이용 해봤으면 한다. 그러면 왜 사람들이 그렇게 열광하는지 알 수 있을것이라 생각한다. 물론 타다 기사 단톡방처럼 문제도 있긴 하지만 단톡방이 아니다 뿐이지 블랙박스 등의 촬영분을 통해 비슷한 문제가 택시에도 있긴 하고 이건 택시에 비해 단점이라기 보다는 인식이라던가 관리의 문제라고 보는게 맞을 것 같다. 물론 옹호하는건 아니다 그런 사람들은 무인도에 보내야 한다. 어떻게 보면 파파, 타다 같은 서비스가 나온건 택시 기사들의 자업자득이 아닐까 싶긴 하다. 물론 누군가는 그럴지도 모르겠다. 일부의 택시 기사들의 행동을 전체로 일반화 하지 말라고 그러면 나는 이렇게 말할것 같다. 그럼 그 일부가 아닌 택시 기사는 도대체 어디 있냐고 글을 더 잘 쓰는 사람이었다면 더 생생히 전달할 수 있겠지만 아쉽게도 그러지 못한것 같다. 그러니 그저 한번 타보시라고 말할 수 밖에 없는 것 같다. 확실한건 택시보다 좋으면 좋았지 못한 경험은 아니실거라고","link":"/2019/07/17/Review/Mobility/파파를-타봤다-이제-택시를-타기-힘들어졌다-아니-못타겠다는게-맞을지도-모르겠다/"}],"tags":[{"name":"Crawling","slug":"Crawling","link":"/tags/Crawling/"},{"name":"Parsing","slug":"Parsing","link":"/tags/Parsing/"},{"name":"Scraping","slug":"Scraping","link":"/tags/Scraping/"},{"name":"크롤링","slug":"크롤링","link":"/tags/크롤링/"},{"name":"스크래핑","slug":"스크래핑","link":"/tags/스크래핑/"},{"name":"파싱","slug":"파싱","link":"/tags/파싱/"},{"name":"nomad","slug":"nomad","link":"/tags/nomad/"},{"name":"daily life","slug":"daily-life","link":"/tags/daily-life/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"memory","slug":"memory","link":"/tags/memory/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"response time","slug":"response-time","link":"/tags/response-time/"},{"name":"Smart Mirror","slug":"Smart-Mirror","link":"/tags/Smart-Mirror/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Android Vision","slug":"Android-Vision","link":"/tags/Android-Vision/"},{"name":"parse-dashboard","slug":"parse-dashboard","link":"/tags/parse-dashboard/"},{"name":"cluster","slug":"cluster","link":"/tags/cluster/"},{"name":"mobility","slug":"mobility","link":"/tags/mobility/"},{"name":"승차공유","slug":"승차공유","link":"/tags/승차공유/"},{"name":"파파","slug":"파파","link":"/tags/파파/"},{"name":"후기","slug":"후기","link":"/tags/후기/"}],"categories":[{"name":"Crawling","slug":"Crawling","link":"/categories/Crawling/"},{"name":"DailyLife","slug":"DailyLife","link":"/categories/DailyLife/"},{"name":"NodeJs","slug":"NodeJs","link":"/categories/NodeJs/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Parse","slug":"NodeJs/Parse","link":"/categories/NodeJs/Parse/"},{"name":"SmartMirror","slug":"Android/SmartMirror","link":"/categories/Android/SmartMirror/"},{"name":"Review","slug":"Review","link":"/categories/Review/"},{"name":"Mobility","slug":"Review/Mobility","link":"/categories/Review/Mobility/"}]}